// -----------------------------------------------------------------------------
//  nexus | OpticalTestGeometry.cc
//
//  * Info          : Detector geometry for optical setting tests.
//  * Author        : <jmunoz@ific.uv.es>
//  * Creation date : February 2020
// -----------------------------------------------------------------------------

#include "OpticalTestGeometry.h"

#include "MaterialsList.h"
#include "OpticalMaterialProperties.h"
#include "XenonGasProperties.h"
#include "Visibilities.h"
#include "PmtSD.h"

#include <G4GenericMessenger.hh>
#include <G4LogicalVolume.hh>
#include <G4LogicalSkinSurface.hh>
#include <G4LogicalBorderSurface.hh>
#include <G4OpticalSurface.hh>
#include <G4Box.hh>
#include <G4Tubs.hh>
#include <G4PVPlacement.hh>
#include <G4NistManager.hh>
#include <G4Material.hh>
#include <G4VisAttributes.hh>
#include <G4SDManager.hh>
#include <G4RunManager.hh>
#include <G4UnitsTable.hh>


using namespace nexus;

OpticalTestGeometry::OpticalTestGeometry():
  BaseGeometry(),
  _verbosity       (false),
  _visibility      (false),
  _msg             (nullptr),
  _wls_placement   ("inside"),       // WLS placement referred to BASE
  _gas_name        ("enrichedXe"),
  _gas_pressure    (15.  * bar),
  _gas_temperature (300. * kelvin),
  _adhoc_x         (0.),             // Vertex-X in case of AD_HOC region
  _adhoc_y         (0.),             // Vertex-Y in case of AD_HOC region
  _adhoc_z         (0.)              // Vertex-Z in case of AD_HOC region
{

  // Messenger
  _msg = new G4GenericMessenger(this, "/Geometry/OpticalTest/",
                                "Control commands of the OpticalTest geometry.");

  // Hard-wired dimensions
  _setup_radius   = 42.5 * mm;
  _sensor_radius  = 500. * cm;
  _base_thickness = 6. * mm;
  _wls_thickness  = 1. * um;


  // Parametrized dimensions
  DefineConfigurationParameters();
}


OpticalTestGeometry::~OpticalTestGeometry()
{
  delete _msg;
}


void OpticalTestGeometry::DefineConfigurationParameters()
{
  // Verbosity
  _msg->DeclareProperty("verbosity", _verbosity, "Verbosity");

  // Visibility
  _msg->DeclareProperty("visibility", _visibility, "Visibility");

  // Gas properties
  _msg->DeclareProperty("gas", _gas_name, "Xenon gas type.");

  G4GenericMessenger::Command& gas_pressure_cmd =
    _msg->DeclareProperty("gas_pressure", _gas_pressure,
                          "Pressure of the xenon gas.");
  gas_pressure_cmd.SetUnitCategory("Pressure");
  gas_pressure_cmd.SetParameterName("gas_pressure", false);
  gas_pressure_cmd.SetRange("gas_pressure>0.");

  G4GenericMessenger::Command& gas_temperature_cmd =
    _msg->DeclareProperty("gas_temperature", _gas_temperature,
                          "Temperature of the xenon gas.");
  gas_temperature_cmd.SetUnitCategory("Temperature");
  gas_temperature_cmd.SetParameterName("gas_temperature", false);
  gas_temperature_cmd.SetRange("gas_temperature>0.");

  // Setup configuration
  _msg->DeclareProperty("wls_placement", _wls_placement, "WLS placement respect to BASE.");

  // Specific vertex in case region to shoot from is AD_HOC
  G4GenericMessenger::Command& _adhoc_x_cmd =
    _msg->DeclareProperty("specific_vertex_X", _adhoc_x,
      "If region is AD_HOC, x coord where particles are generated");
  _adhoc_x_cmd.SetParameterName("specific_vertex_X", false);
  _adhoc_x_cmd.SetUnitCategory("Length");

  G4GenericMessenger::Command& _adhoc_y_cmd =
    _msg->DeclareProperty("specific_vertex_Y", _adhoc_y,
      "If region is AD_HOC, y coord where particles are generated");
  _adhoc_y_cmd.SetParameterName("specific_vertex_Y", false);
  _adhoc_y_cmd.SetUnitCategory("Length");

  G4GenericMessenger::Command& _adhoc_z_cmd =
    _msg->DeclareProperty("specific_vertex_Z", _adhoc_z,
      "If region is AD_HOC, z coord where particles are generated");
  _adhoc_z_cmd.SetParameterName("specific_vertex_Z", false);
  _adhoc_z_cmd.SetUnitCategory("Length");
}



void OpticalTestGeometry::DefineMaterials()
{
  // Defining the gas xenon
  if (_gas_name == "naturalXe")
    _xenon_gas = MaterialsList::GXe(_gas_pressure, _gas_temperature);

  else if (_gas_name == "enrichedXe")
    _xenon_gas = MaterialsList::GXeEnriched(_gas_pressure, _gas_temperature);

  else if (_gas_name == "depletedXe")
    _xenon_gas = MaterialsList::GXeDepleted(_gas_pressure, _gas_temperature);

  else
    G4Exception("[NextParam]", "DefineMaterials()", FatalException,
    "Unknown xenon gas type. Valid options are naturalXe, enrichedXe or depletedXe.");
  _xenon_gas->SetMaterialPropertiesTable(OpticalMaterialProperties::GXe(_gas_pressure,
                                                                        _gas_temperature,
                                                                        25510 * (1./MeV)));

  // The WLS material
  _wls_mat = MaterialsList::TPB();
  _wls_mat->SetMaterialPropertiesTable(OpticalMaterialProperties::TPB());

  // The PEDOT material
  _pedot_mat = MaterialsList::ITO();
  _pedot_mat->SetMaterialPropertiesTable(OpticalMaterialProperties::PEDOT());

  // The Sapphire material
  _sapphire_mat = MaterialsList::Sapphire();
  _sapphire_mat->SetMaterialPropertiesTable(OpticalMaterialProperties::Sapphire());
}



void OpticalTestGeometry::Construct()
{

  // Verbosity
  if(_verbosity) {
    G4cout << G4endl << "***** Verbosing OPTICAL_TEST geometry *****" << G4endl;
  }

  // Define materials.
  DefineMaterials();


  // The lab
  G4String lab_name = "LABORATORY";
  G4double lab_size = 50. * m;

  G4Box* lab_solid = new G4Box(lab_name, lab_size/2.,
                               lab_size/2., lab_size/2.);

  G4LogicalVolume* lab_logic = new G4LogicalVolume(lab_solid,
                                                   _xenon_gas, lab_name);

  BaseGeometry::SetLogicalVolume(lab_logic);

  lab_logic->SetVisAttributes(G4VisAttributes::Invisible);


  // The gas
  G4String gas_name = "GAS";
  G4double gas_size = 20. * m;

  G4Box* gas_solid = new G4Box(gas_name, gas_size/2.,
                               gas_size/2., gas_size/2.);

  G4LogicalVolume* gas_logic = new G4LogicalVolume(gas_solid,
                                                   _xenon_gas, gas_name);

  gas_logic->SetVisAttributes(G4VisAttributes::Invisible);

  _gas_phys = 
    new G4PVPlacement(nullptr, G4ThreeVector(0.,0.,0.), gas_logic,
                      gas_name, lab_logic, false, 0, true);


  // Build the setup to study
  BuildSetup(gas_logic);

  // Build the detectors
  BuildSensors(gas_logic);

  // Verbosity
  if(_verbosity) G4cout << G4endl;
}



void OpticalTestGeometry::BuildSetup(G4LogicalVolume* mother_logic) {
  // The SETUP consist of a base material and a WLS material
  // The WLS material can be placed inside the BASE or outside
  // The whole setup always ends at Z=0.

  // Verbosity
  if(_verbosity) {
    G4cout << G4endl << "*** OpticalTest SETUP ..." << G4endl;
  }


  /// Dimensions & Settings ///
  G4String base_name      = "BASE";
  G4String wls_name       = "WLS";


  /// Building the BASE ///
  G4Tubs* base_solid =
    new G4Tubs(base_name, 0., _setup_radius, _base_thickness/2., 0, twopi);

//  G4Material* teflon_mat = G4NistManager::Instance()->FindOrBuildMaterial("G4_TEFLON");
//
//  G4LogicalVolume* base_logic =
//    new G4LogicalVolume(base_solid, teflon_mat, base_name);
//
//  ///////////////////////
//  // BASE optical surface
//  G4OpticalSurface* base_optSurf = 
//    new G4OpticalSurface(base_name, unified, ground, dielectric_metal);
//
//  base_optSurf->SetMaterialPropertiesTable(OpticalMaterialProperties::PTFE());
//
//  new G4LogicalSkinSurface(base_name, base_logic, base_optSurf);

  G4LogicalVolume* base_logic =
    new G4LogicalVolume(base_solid, _sapphire_mat, base_name);


  // Visibility
  if (_visibility) base_logic->SetVisAttributes(nexus::White());
  else             base_logic->SetVisAttributes(G4VisAttributes::Invisible);
  

  /// Building the WLS ///
  G4Tubs* wls_solid =
    new G4Tubs(wls_name, 0., _setup_radius, _wls_thickness/2., 0, twopi);

  G4LogicalVolume* wls_logic =
    new G4LogicalVolume(wls_solid, _wls_mat, wls_name);

  // Visibility
  if (_visibility) wls_logic->SetVisAttributes(nexus::White());
  else             wls_logic->SetVisAttributes(G4VisAttributes::Invisible);


  /////////////////////
  /// WLS placement ///

  // WLS placement: outside BASE
  if (_wls_placement == "outside") {
    G4double wls_posZ  = - _wls_thickness / 2.;
    G4double base_posZ = - _wls_thickness - _base_thickness / 2.;
  
    new G4PVPlacement(nullptr, G4ThreeVector(0., 0., base_posZ), base_logic,
                      base_name, mother_logic, false, 0, _verbosity);
  
    _wls_phys = 
      new G4PVPlacement(nullptr, G4ThreeVector(0., 0., wls_posZ), wls_logic,
                        wls_name, mother_logic, false, 0, _verbosity);
  }

  // WLS placement: inside BASE
  else if (_wls_placement == "inside") {
    G4double wls_posZ  =   _base_thickness / 2. - _wls_thickness / 2.;
    G4double base_posZ = - _base_thickness / 2.;
  
    new G4PVPlacement(nullptr, G4ThreeVector(0., 0., base_posZ), base_logic,
                      base_name, mother_logic, false, 0, _verbosity);
  
    _wls_phys = 
      new G4PVPlacement(nullptr, G4ThreeVector(0., 0., wls_posZ), wls_logic,
                        wls_name, base_logic, false, 0, _verbosity);
  }

  // WLS placement: NONE (== It doesn't exist)
  else if (_wls_placement == "none") {
    G4double base_posZ = - _base_thickness / 2.;

    new G4PVPlacement(nullptr, G4ThreeVector(0., 0., base_posZ), base_logic,
                      base_name, mother_logic, false, 0, _verbosity);
  }

  // Wrong WLS placement
  else
    G4Exception("OpticalTestGeometry::OpticalTestGeometry",
                "Unknown wls_placement", FatalException,
                "Unknown wls_placement. Valid options are outside, inside & none.");


  //////////////////////
  // WLS optical surface
  if ( (_wls_placement == "outside") || (_wls_placement == "inside")) {
    G4OpticalSurface* wls_optSurf = 
      new G4OpticalSurface(wls_name, glisur, ground, dielectric_dielectric, 0.01);
    
    // Apparently is not needed
    //wls_optSurf->SetMaterialPropertiesTable(OpticalMaterialProperties::TPB());

    // This option yields wrong results in case of TPB over TEFLON
    new G4LogicalSkinSurface(wls_name, wls_logic, wls_optSurf);

    //new G4LogicalBorderSurface("WLS_GAS_surf", _wls_phys, _gas_phys, wls_optSurf);
    //new G4LogicalBorderSurface("GAS_WLS_surf", _gas_phys, _wls_phys, wls_optSurf);
  }


//  /// Building the PEDOT layer ///
//  G4String pedot_name      = "PEDOT";
//  G4double pedot_thickness = 15 * nm;
//    G4double pedot_posZ  = _base_thickness/2. - _wls_thickness - pedot_thickness/2.;
//
//  G4Tubs* pedot_solid =
//    new G4Tubs(pedot_name, 0., _setup_radius, pedot_thickness/2., 0, twopi);
//
//  G4LogicalVolume* pedot_logic =
//    new G4LogicalVolume(pedot_solid, _pedot_mat, pedot_name);
//
//  // Visibility
//  if (_visibility) pedot_logic->SetVisAttributes(nexus::Blue());
//  else             pedot_logic->SetVisAttributes(G4VisAttributes::Invisible);
//
//  new G4PVPlacement(nullptr, G4ThreeVector(0., 0., pedot_posZ), pedot_logic,
//                    pedot_name, base_logic, false, 0, _verbosity);


//  // PEDOT Opt Surface
//  G4OpticalSurface* pedot_optSurf = 
//    new G4OpticalSurface(pedot_name, glisur, ground, dielectric_dielectric, 0.01);    
//
//  // This option yields wrong results in case of TPB over TEFLON
//  new G4LogicalSkinSurface(pedot_name, pedot_logic, pedot_optSurf);


}



void OpticalTestGeometry::BuildSensors(G4LogicalVolume* mother_logic) {

  // Verbosity
  if(_verbosity) {
    G4cout << G4endl << "*** OpticalTest SENSORS ..." << G4endl;
  }

  // Building the sensors
  G4String sensor_name       = "SENSOR";
  G4String front_sensor_name = "FRONT_SENSOR";
  G4String rear_sensor_name  = "REAR_SENSOR";
  G4String lat_sensor_name   = "LATERAL_SENSOR";

  G4Material* sensor_mat = G4NistManager::Instance()->FindOrBuildMaterial("G4_Si");

  G4double sensor_thickness   =    1. * mm;
  G4double front_sensor_posZ  =   10. * mm + sensor_thickness/2.;
  G4double rear_sensor_posZ   = - _base_thickness - sensor_thickness/2.;
  G4double lat_sensor_posZ    = - _base_thickness/2.;

  G4Tubs* sensor_solid =
    new G4Tubs(sensor_name, 0., _sensor_radius, sensor_thickness/2., 0., twopi);

  G4LogicalVolume* front_sensor_logic =
    new G4LogicalVolume(sensor_solid, sensor_mat, front_sensor_name);

  G4LogicalVolume* rear_sensor_logic =
    new G4LogicalVolume(sensor_solid, sensor_mat, rear_sensor_name);


  G4Tubs* lat_sensor_solid =
    new G4Tubs(lat_sensor_name, _setup_radius, _setup_radius + sensor_thickness,
               _base_thickness/2., 0., twopi);

  G4LogicalVolume* lat_sensor_logic =
    new G4LogicalVolume(lat_sensor_solid, sensor_mat, lat_sensor_name);


  // Visibilities
  if (_visibility) {
    front_sensor_logic->SetVisAttributes(nexus::BloodRed());
    rear_sensor_logic ->SetVisAttributes(nexus::BloodRed());
    lat_sensor_logic  ->SetVisAttributes(nexus::BloodRed());
  }
  else {
    front_sensor_logic->SetVisAttributes(G4VisAttributes::Invisible);
    rear_sensor_logic ->SetVisAttributes(G4VisAttributes::Invisible);
    lat_sensor_logic  ->SetVisAttributes(G4VisAttributes::Invisible);
  }


  // Optical properties
  G4MaterialPropertiesTable* sensor_optProp = new G4MaterialPropertiesTable();

  const G4int entries = 2;
  G4double energies[entries] = {0.20 * eV, 12.4 * eV};

  // It does not reflect anything
  G4double sensor_reflectivity[entries] = {0., 0.};
  sensor_optProp->AddProperty("REFLECTIVITY", energies,
                              sensor_reflectivity, entries);

  // It detects everything
  G4double sensor_efficiency[entries] = {1., 1.};
  sensor_optProp->AddProperty("EFFICIENCY", energies,
                              sensor_efficiency, entries);

  // Building the optical surface
  G4OpticalSurface* sensor_optSurf = 
    new G4OpticalSurface(sensor_name, unified, polished, dielectric_metal);
  sensor_optSurf->SetMaterialPropertiesTable(sensor_optProp);

  // Giving the optical surface to sensors
  new G4LogicalSkinSurface(front_sensor_name, front_sensor_logic, sensor_optSurf);
  new G4LogicalSkinSurface(rear_sensor_name,  rear_sensor_logic,  sensor_optSurf);
  new G4LogicalSkinSurface(lat_sensor_name,   lat_sensor_logic,   sensor_optSurf);


  // Sensitive detector 
  G4SDManager* sdmgr = G4SDManager::GetSDMpointer();
  if (!sdmgr->FindSensitiveDetector(sensor_name, false)) {
    PmtSD* sensor_sd = new PmtSD(sensor_name);
    sensor_sd->SetDetectorVolumeDepth(0);
    sensor_sd->SetMotherVolumeDepth(0);
    sensor_sd->SetTimeBinning(1. * us);
    G4SDManager::GetSDMpointer()->AddNewDetector(sensor_sd);
    front_sensor_logic->SetSensitiveDetector(sensor_sd);
    rear_sensor_logic ->SetSensitiveDetector(sensor_sd);
    lat_sensor_logic  ->SetSensitiveDetector(sensor_sd);
  }

  // Placing the sensors
  new G4PVPlacement(nullptr, G4ThreeVector(0., 0., front_sensor_posZ), front_sensor_logic,
                    front_sensor_name, mother_logic, false, 0, true);

  new G4PVPlacement(nullptr, G4ThreeVector(0., 0., rear_sensor_posZ), rear_sensor_logic,
                    rear_sensor_name, mother_logic, false, 0, true);

  new G4PVPlacement(nullptr, G4ThreeVector(0., 0., lat_sensor_posZ), lat_sensor_logic,
                    lat_sensor_name, mother_logic, false, 0, true);

}



G4ThreeVector OpticalTestGeometry::GenerateVertex(const G4String& region) const
{
  G4ThreeVector vertex;

  if (region == "AD_HOC") {
    vertex = G4ThreeVector(_adhoc_x, _adhoc_y, _adhoc_z);
  }

  else {
    G4Exception("[OpticalTestGeometry]", "GenerateVertex()", FatalException,
      "Unknown vertex generation region!");
  }

  return vertex;
}
