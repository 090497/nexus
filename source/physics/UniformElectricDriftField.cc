// ----------------------------------------------------------------------------
//  $Id$
//
//  Author : J Martin-Albo <jmalbos@ific.uv.es>    
//  Created: 12 May 2010
//
//  Copyright (c) 2010-2012 NEXT Collaboration. All rights reserved.
// ----------------------------------------------------------------------------

#include "UniformElectricDriftField.h"

#include "DriftTrackInfo.h"
#include "SegmentPointSampler.h"

#include <Randomize.hh>
#include <G4Material.hh>
#include <G4MaterialPropertiesTable.hh>



namespace nexus {
  
  
  const G4double UniformElectricDriftField::_secmargin = 1. * micrometer;

  
  UniformElectricDriftField::UniformElectricDriftField
  (G4double anode_position, G4double cathode_position, EAxis axis): 
    BaseDriftField(), 
    _axis(axis), _anode_pos(anode_position), _cathode_pos(cathode_position),
    _drift_velocity(0.), _longit_diff(0.), _transv_diff(0.),
    _attachment(999.*second), _light_yield(0), _num_ph(-999)
  {
    // initialize random generator with dummy values
    _rnd = new SegmentPointSampler(G4LorentzVector(0.,0.,0.,-999.),
				   G4LorentzVector(0.,0.,0.,-999.));
  }
  
  
  
  UniformElectricDriftField::~UniformElectricDriftField()
  {
    delete _rnd;
  }
  
  
  
  G4double UniformElectricDriftField::Drift(DriftTrackInfo* info)
  {
    G4LorentzVector pre = info->GetPreDriftPoint();
    
    // If the origin is not between anode and cathode,
    // the charge carrier, obviously, doesn't move.
    if (!CheckCoordinate(pre[_axis]))
      return 0.;
    
    // Calculate distance to anode and corresponding drift time
    G4double drift_length = _anode_pos - pre[_axis];
    G4double drift_time = drift_length / _drift_velocity;

    // The electron may get attached to an impurity before reaching the anode.
    G4double rnd = -_attachment * std::log(G4UniformRand());
    if (drift_time > rnd) {
      drift_time = rnd;
      drift_length = _drift_velocity * drift_time;
      info->SetDriftStatus(ATTACHED);
    }
    else {
      info->SetDriftStatus(ALIVE);
    }
    
    // Calculate longitudinal and transversal deviation due to diffusion
    G4double transv_sigma = _transv_diff * sqrt(drift_length);
    G4double longit_sigma = _longit_diff * sqrt(drift_length);
    G4double time_sigma = longit_sigma / _drift_velocity;
    
    // Generate a final position and time for the drifting particle
    // taking into account the gaussian deviation with respect to the
    // straight path due to diffusion
    G4ThreeVector position;
    G4double time;

    for (G4int i=0; i<3; i++) {
      // Transverse coordinate
      if (i != _axis) {
  	position[i] = G4RandGauss::shoot(pre[i], transv_sigma);
      }
      // Longitudinal coordinate
      else if (i == _axis) { 
  	// the final position in the drift direction
	// corresponds to the anode position (plus a security
	// margin to avoid rounding effects in the geometry navigation)
	position[i] = pre[i] + drift_length + _secmargin;
	time = G4RandGauss::shoot(drift_time, time_sigma);

	// For short drift lengths, a negative drift time can be
	// generated (thus violating causality: the particle reaches
	// the anode before drifting). In these cases, take the
	// drift time instead.
	if (time < 0.) time = drift_time;

	time = time + pre.t();
      }
    }
    
    G4LorentzVector post(position, time);

    // Set properties in the drift info store
    info->SetPostDriftPoint(post);
    info->SetDriftLength(drift_length);
    info->SetDriftTime(drift_time);
    info->SetTimeSpread(time_sigma);
    info->SetLongitudinalSpread(longit_sigma);
    info->SetTransverseSpread(transv_sigma);
    
    // two possibilities for the number of photons generated by the
    // electron while drifting:
    // 1) a fixed number of photons per drift step
    if (_num_ph > 0) 
      info->SetNumberOfPhotons(_num_ph);
    // 2) a yield per unit length (default)
    else 
      info->SetNumberOfPhotons(drift_length*_light_yield);
    
    // Calculate step lenght as euclidean distance between origin and end
    G4ThreeVector displacement = position - pre.vect();
    G4double step_length = displacement.mag();
    return step_length;
  }
  
  
  
  G4LorentzVector UniformElectricDriftField::GeneratePointAlongDriftLine
  (const G4LorentzVector& origin)
  {
    if (origin != _rnd->GetPrePoint()) {
      DriftTrackInfo* info = new DriftTrackInfo();
      info->SetPreDriftPoint(origin);
      Drift(info);
      _rnd->SetPoints(info->GetPreDriftPoint(), 
		      info->GetPostDriftPoint());
      delete info;
    }
    
    return _rnd->Shoot();
  }



  G4bool UniformElectricDriftField::CheckCoordinate(G4double coord)
  {
    G4double max_coord = std::max(_anode_pos, _cathode_pos);
    G4double min_coord = std::min(_anode_pos, _cathode_pos);
    return !((coord > max_coord) || (coord < min_coord));
  }
  
  
} // end namespace nexus
