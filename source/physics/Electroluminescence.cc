// -----------------------------------------------------------------------------
//  $Id$
//
//  Author:  J. Martin-Albo <jmalbos@ific.uv.es>    
//  Created: 28 Oct 2009
//  
//  Copyright (c) 2009-2012 NEXT Collaboration. All rights reserved.
// ----------------------------------------------------------------------------- 

#include "Electroluminescence.h"

#include "IonizationElectron.h"
#include "DriftTrackInfo.h"
#include "BaseDriftField.h"
#include "G4Scintillation.hh"
#include "G4Material.hh" 
#include "G4MaterialPropertiesTable.hh"
#include "G4PhysicsOrderedFreeVector.hh"


#include <G4ProcessTable.hh>
#include <G4TransportationManager.hh>
#include <G4OpticalPhoton.hh>
#include <G4Electron.hh>
#include <Randomize.hh>
#include <G4Poisson.hh>




namespace nexus {

  
  Electroluminescence::Electroluminescence(const G4String& process_name,
					   G4ProcessType type):
    G4VDiscreteProcess(process_name, type), _secondaries_first(true)

  {
    pParticleChange = &_ParticleChange;
    
    _SlowIntegralTable = NULL;
    _FastIntegralTable = NULL;

    G4Scintillation* scint = 
      dynamic_cast<G4Scintillation*>(G4ProcessTable::GetProcessTable()->
				     FindProcess("Scintillation", 
						 G4Electron::Definition()));
    
    if (scint) {
      _SlowIntegralTable = scint->GetSlowIntegralTable();
      _FastIntegralTable = scint->GetFastIntegralTable();
    }
    else {
      G4String msg = " ERROR: Scintillation integral tables do not exist!";
      G4Exception("[Electroluminescence]", "Electroluminescence()", 
		  FatalException, msg);
    }
  }
  
  
  
  Electroluminescence::~Electroluminescence()
  {
  }
  
  
  
  G4bool Electroluminescence::IsApplicable(const G4ParticleDefinition& pdef)
  {
    return (pdef == *IonizationElectron::Definition());
  }



  G4VParticleChange*
  Electroluminescence::PostStepDoIt(const G4Track& track, const G4Step& step)
  {
    // Initialize particle change with current track values
    _ParticleChange.Initialize(track);
    
    // Get the current region and its associated drift field
    G4Region* region = track.GetVolume()->GetLogicalVolume()->GetRegion();
    BaseDriftField* field = 
      dynamic_cast<BaseDriftField*>(region->GetUserInformation());

    // If no drift field is defined (i.e., the dynamic_cast returned 
    // a null pointer), kill the track and finish the process
    if (!field) {
      _ParticleChange.ProposeTrackStatus(fStopAndKill);
      return G4VDiscreteProcess::PostStepDoIt(track, step);
    }

    //////////////////////////////////////////////////////////////////
    // Determine number of photons to be generated by the process
    
    // Get the drift info associated to the track
    DriftTrackInfo* drift_info =
      dynamic_cast<DriftTrackInfo*>(track.GetUserInformation());
    if (!drift_info) {
      G4ExceptionDescription ed;
      ed << "Ionization drift cannot be done on track with no DriftTrackInfo.";
      G4Exception("[Electrominescence]", "PostStepDoIt()",
		  EventMustBeAborted, ed);
    }
    
    G4int num_photons = drift_info->GetNumberOfPhotons();

    // Poissonian regime
    if (num_photons < 10) {
      num_photons = G4int(G4Poisson(num_photons));
    }
    // Gaussian regime
    else {
      G4double sigma = std::sqrt(num_photons);
      num_photons = G4int(G4RandGauss::shoot(num_photons, sigma) + 0.5);
    }
    
    _ParticleChange.SetNumberOfSecondaries(num_photons);
    
    if (_secondaries_first && num_photons>0) {
      if (track.GetTrackStatus() == fAlive)
	_ParticleChange.ProposeTrackStatus(fSuspend);
    }
    
    //////////////////////////////////////////////////////////////////
    // Scintillation properties
    
    const G4Material* material = track.GetMaterial();

    G4MaterialPropertiesTable* mpt = material->GetMaterialPropertiesTable();
    if (!mpt) return G4VDiscreteProcess::PostStepDoIt(track, step);
    
    G4MaterialPropertyVector* Fast_Intensity = 
      mpt->GetProperty("FASTCOMPONENT"); 
    G4MaterialPropertyVector* Slow_Intensity =
      mpt->GetProperty("SLOWCOMPONENT");

    if (!Fast_Intensity && !Slow_Intensity )
      return G4VDiscreteProcess::PostStepDoIt(track, step);

    G4int nscnt = 1;
    if (Fast_Intensity && Slow_Intensity) nscnt = 2;

    

    //////////////////////////////////////////////////////////////////

    G4int materialIndex = material->GetIndex();

    G4int Num = num_photons;
    G4int NumPhotons = num_photons;
    G4bool fFiniteRiseTime = false;
    
    
    for (G4int scnt = 1; scnt <= nscnt; scnt++) {
      
      G4double ScintillationTime = 0.*ns;
      G4double ScintillationRiseTime = 0.*ns;
      G4PhysicsOrderedFreeVector* ScintillationIntegral = NULL;

      if (scnt == 1) {

	if (nscnt == 1) {
	  
	  if(Fast_Intensity){
	    ScintillationTime   = mpt->GetConstProperty("FASTTIMECONSTANT");
	    if (fFiniteRiseTime) {
	      ScintillationRiseTime = mpt->
		GetConstProperty("FASTSCINTILLATIONRISETIME");
	    }
	    ScintillationIntegral = (G4PhysicsOrderedFreeVector*)
	      ((*_FastIntegralTable)(materialIndex));
	  }
	  if(Slow_Intensity){
	    ScintillationTime   = mpt->
	      GetConstProperty("SLOWTIMECONSTANT");
	    if (fFiniteRiseTime) {
	      ScintillationRiseTime = mpt->
		GetConstProperty("SLOWSCINTILLATIONRISETIME");
	    }
	    ScintillationIntegral = (G4PhysicsOrderedFreeVector*)
	      ((*_SlowIntegralTable)(materialIndex));
	  }
	}
	else {
	  G4double YieldRatio = mpt->
	    GetConstProperty("YIELDRATIO");
	  
	  Num = G4int (std::min(YieldRatio,1.0) * NumPhotons);
	  ScintillationTime   = mpt->
	    GetConstProperty("FASTTIMECONSTANT");
	  if (fFiniteRiseTime) {
	    ScintillationRiseTime = mpt->
	      GetConstProperty("FASTSCINTILLATIONRISETIME");
	  }
	  ScintillationIntegral =
	    (G4PhysicsOrderedFreeVector*)((*_FastIntegralTable)(materialIndex));
	}
      }
      else {
	Num = NumPhotons - Num;
	ScintillationTime   =   mpt->
	  GetConstProperty("SLOWTIMECONSTANT");
	if (fFiniteRiseTime) {
	  ScintillationRiseTime = mpt->
	    GetConstProperty("SLOWSCINTILLATIONRISETIME");
	}
	ScintillationIntegral =
	  (G4PhysicsOrderedFreeVector*)((*_SlowIntegralTable)(materialIndex));
      }

      if (!ScintillationIntegral) continue;
	
      // Max Scintillation Integral
 
      G4double CIImax = ScintillationIntegral->GetMaxValue();

      for (G4int i = 0; i < Num; i++) {

	// Determine photon energy

	G4double CIIvalue = G4UniformRand() * CIImax;
	G4double energy = ScintillationIntegral->GetEnergy(CIIvalue);

	// Generate a random direction for the photon
	// (electroluminescence is supposed isotropic)

	G4double cos_theta = 1. - 2. * G4UniformRand();
	G4double sin_theta = std::sqrt((1.-cos_theta)*(1.+cos_theta));

	G4double phi = twopi * G4UniformRand();
	G4double sin_phi = std::sin(phi);
	G4double cos_phi = std::cos(phi);

	G4double px = sin_theta * cos_phi;
	G4double py = sin_theta * sin_phi;
	G4double pz = cos_theta;

	G4ParticleMomentum momentum(px, py, pz);

	// Determine polarization of new photon 

	G4double sx = cos_theta * cos_phi;
	G4double sy = cos_theta * sin_phi; 
	G4double sz =-sin_theta;

	G4ThreeVector polarization(sx, sy, sz);

	phi = twopi * G4UniformRand();
	sin_phi = std::sin(phi);
	cos_phi = std::cos(phi);

	polarization = 
	  cos_phi * polarization + sin_phi * momentum.cross(polarization);
	polarization = polarization.unit();

	// Generate a new photon and set properties

	G4DynamicParticle* photon =
	  new G4DynamicParticle(G4OpticalPhoton::Definition(), momentum);

	photon->SetPolarization(polarization.x(),
				polarization.y(),
				polarization.z());
	
	photon->SetKineticEnergy(energy);

	G4LorentzVector pre = drift_info->GetPreDriftPoint();
	G4LorentzVector xyzt = field->GeneratePointAlongDriftLine(pre);
	
	// // emission time distribution
	// if (ScintillationRiseTime==0.0) {
	//   deltaTime = deltaTime - 
	//     ScintillationTime * std::log( G4UniformRand() );
	// } else {
	//   deltaTime = deltaTime +
	//     sample_time(ScintillationRiseTime, ScintillationTime);
	// }

	// G4double aSecondaryTime = t0 + deltaTime;

	// G4ThreeVector aSecondaryPosition =
	//   x0 + rand * step.GetDeltaPosition();

	G4Track* secondary = new G4Track(photon, xyzt.t(), xyzt.v());
	secondary->SetParentID(track.GetTrackID());

	_ParticleChange.AddSecondary(secondary);
      }
    }

    return G4VDiscreteProcess::PostStepDoIt(track, step);
  }
  
  
  
  G4double Electroluminescence::GetMeanFreePath
  (const G4Track&, G4double, G4ForceCondition* condition)
  {
    *condition = StronglyForced;
    return DBL_MAX;
  }
  

} // end namespace nexus
